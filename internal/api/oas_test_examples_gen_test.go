// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAcceptanceResponse_EncodeDecode(t *testing.T) {
	var typ AcceptanceResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AcceptanceResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivateUserBadRequest_EncodeDecode(t *testing.T) {
	var typ ActivateUserBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivateUserBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivateUserInternalServerError_EncodeDecode(t *testing.T) {
	var typ ActivateUserInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivateUserInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivateUserNotFound_EncodeDecode(t *testing.T) {
	var typ ActivateUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivateUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivateUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivateUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivateUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivateUserUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ ActivateUserUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivateUserUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteMessageBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteMessageInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteMessageNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteMessageUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteMessageUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ DeleteMessageUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteMessageUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorResponse_EncodeDecode(t *testing.T) {
	var typ ErrorResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageBadRequest_EncodeDecode(t *testing.T) {
	var typ GetMessageBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetMessageInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageNotFound_EncodeDecode(t *testing.T) {
	var typ GetMessageNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetMessageUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetMessageUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetMessageUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetMessageUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserMessagesBadRequest_EncodeDecode(t *testing.T) {
	var typ GetUserMessagesBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserMessagesBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserMessagesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUserMessagesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserMessagesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserMessagesNotFound_EncodeDecode(t *testing.T) {
	var typ GetUserMessagesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserMessagesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserMessagesUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetUserMessagesUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserMessagesUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserMessagesUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ GetUserMessagesUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserMessagesUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageRequest_EncodeDecode(t *testing.T) {
	var typ MessageRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessageResponse_EncodeDecode(t *testing.T) {
	var typ MessageResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessageResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessagesMetadataResponse_EncodeDecode(t *testing.T) {
	var typ MessagesMetadataResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessagesMetadataResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMessagesResponse_EncodeDecode(t *testing.T) {
	var typ MessagesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MessagesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewAccessTokenBadRequest_EncodeDecode(t *testing.T) {
	var typ NewAccessTokenBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewAccessTokenBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewAccessTokenInternalServerError_EncodeDecode(t *testing.T) {
	var typ NewAccessTokenInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewAccessTokenInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewAccessTokenUnauthorized_EncodeDecode(t *testing.T) {
	var typ NewAccessTokenUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewAccessTokenUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewActivationTokenBadRequest_EncodeDecode(t *testing.T) {
	var typ NewActivationTokenBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewActivationTokenBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewActivationTokenInternalServerError_EncodeDecode(t *testing.T) {
	var typ NewActivationTokenInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewActivationTokenInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewActivationTokenNotFound_EncodeDecode(t *testing.T) {
	var typ NewActivationTokenNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewActivationTokenNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewActivationTokenUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ NewActivationTokenUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewActivationTokenUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewMessageBadRequest_EncodeDecode(t *testing.T) {
	var typ NewMessageBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewMessageBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewMessageInternalServerError_EncodeDecode(t *testing.T) {
	var typ NewMessageInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewMessageInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewMessageNotFound_EncodeDecode(t *testing.T) {
	var typ NewMessageNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewMessageNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewMessageUnauthorized_EncodeDecode(t *testing.T) {
	var typ NewMessageUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewMessageUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewMessageUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ NewMessageUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewMessageUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewPasswordResetTokenBadRequest_EncodeDecode(t *testing.T) {
	var typ NewPasswordResetTokenBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewPasswordResetTokenBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewPasswordResetTokenInternalServerError_EncodeDecode(t *testing.T) {
	var typ NewPasswordResetTokenInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewPasswordResetTokenInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewPasswordResetTokenNotFound_EncodeDecode(t *testing.T) {
	var typ NewPasswordResetTokenNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewPasswordResetTokenNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewPasswordResetTokenUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ NewPasswordResetTokenUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewPasswordResetTokenUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewRefreshTokenBadRequest_EncodeDecode(t *testing.T) {
	var typ NewRefreshTokenBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewRefreshTokenBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewRefreshTokenInternalServerError_EncodeDecode(t *testing.T) {
	var typ NewRefreshTokenInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewRefreshTokenInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewRefreshTokenNotFound_EncodeDecode(t *testing.T) {
	var typ NewRefreshTokenNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewRefreshTokenNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewRefreshTokenUnauthorized_EncodeDecode(t *testing.T) {
	var typ NewRefreshTokenUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewRefreshTokenUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewRefreshTokenUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ NewRefreshTokenUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewRefreshTokenUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewUserBadRequest_EncodeDecode(t *testing.T) {
	var typ NewUserBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewUserBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewUserInternalServerError_EncodeDecode(t *testing.T) {
	var typ NewUserInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewUserInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewUserNotFound_EncodeDecode(t *testing.T) {
	var typ NewUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewUserUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ NewUserUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewUserUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenRequest_EncodeDecode(t *testing.T) {
	var typ TokenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateMessageBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateMessageBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateMessageBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateMessageConflict_EncodeDecode(t *testing.T) {
	var typ UpdateMessageConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateMessageConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateMessageInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateMessageInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateMessageInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateMessageNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateMessageNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateMessageNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateMessageUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateMessageUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateMessageUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateMessageUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ UpdateMessageUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateMessageUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserPasswordBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateUserPasswordBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserPasswordBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserPasswordInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateUserPasswordInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserPasswordInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserPasswordNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateUserPasswordNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserPasswordNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserPasswordRequest_EncodeDecode(t *testing.T) {
	var typ UpdateUserPasswordRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserPasswordRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserPasswordUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateUserPasswordUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserPasswordUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserPasswordUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ UpdateUserPasswordUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserPasswordUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserEmailRequest_EncodeDecode(t *testing.T) {
	var typ UserEmailRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserEmailRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserLoginRequest_EncodeDecode(t *testing.T) {
	var typ UserLoginRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserLoginRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserRequest_EncodeDecode(t *testing.T) {
	var typ UserRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponse_EncodeDecode(t *testing.T) {
	var typ UserResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
